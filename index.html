<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mengtian 2026 Countdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">

    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://esm.sh/three@0.150.1",
        "three/": "https://esm.sh/three@0.150.1/",
        "react": "https://esm.sh/react@18.2.0",
        "react/": "https://esm.sh/react@18.2.0/",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/": "https://esm.sh/react-dom@18.2.0/",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.13.0?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.65.0?external=react,react-dom,three,@react-three/fiber",
        "postprocessing": "https://esm.sh/postprocessing@6.30.2?external=three",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.14.0?external=react,react-dom,three,@react-three/fiber,postprocessing"
      }
    }
    </script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef, useMemo, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame } from '@react-three/fiber';
      import { EffectComposer, Bloom } from '@react-three/postprocessing';

      // --- HOOKS ---

      const useCountdown = (targetDate) => {
        const calculateTimeLeft = () => {
          const difference = +new Date(targetDate) - +new Date();
          
          if (difference > 0) {
            return {
              days: Math.floor(difference / (1000 * 60 * 60 * 24)),
              hours: Math.floor((difference / (1000 * 60 * 60)) % 24),
              minutes: Math.floor((difference / 1000 / 60) % 60),
              seconds: Math.floor((difference / 1000) % 60),
            };
          }

          return { days: 0, hours: 0, minutes: 0, seconds: 0 };
        };

        const [timeLeft, setTimeLeft] = useState(calculateTimeLeft());

        useEffect(() => {
          const timer = setInterval(() => {
            setTimeLeft(calculateTimeLeft());
          }, 1000);

          return () => clearInterval(timer);
        }, [targetDate]);

        return timeLeft;
      };

      // --- COMPONENTS ---

      const ParticleText = ({ 
        text, 
        size, 
        position, 
        color, 
        density = 1.5,
        fontFamily = '"Microsoft YaHei", "SimHei", sans-serif'
      }) => {
        const pointsRef = useRef(null);
        const [fontLoaded, setFontLoaded] = useState(false);

        // Ensure fonts are ready before rendering
        useEffect(() => {
          document.fonts.ready.then(() => {
            setFontLoaded(true);
          });
        }, []);
        
        const particles = useMemo(() => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          if (!ctx) return new Float32Array(0);

          const fontSize = 100 * density; 
          const fontStyle = `900 ${fontSize}px ${fontFamily}`;
          ctx.font = fontStyle;

          const textMetrics = ctx.measureText(text);
          const width = Math.ceil(textMetrics.width);
          const height = Math.ceil(fontSize * 1.5);

          canvas.width = width;
          canvas.height = height;

          ctx.font = fontStyle;
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          ctx.fillText(text, width / 2, height / 2);

          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          
          const points = [];
          const step = 2; 
          
          for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
              const i = (y * width + x) * 4;
              if (data[i + 3] > 64) {
                const scale = size / fontSize; 
                const posX = (x - width / 2) * scale;
                const posY = -(y - height / 2) * scale;
                const posZ = (Math.random() - 0.5) * (size * 0.15); 
                points.push(posX, posY, posZ);
              }
            }
          }
          
          return new Float32Array(points);
        }, [text, size, density, fontFamily, fontLoaded]);

        useFrame((state) => {
          if (!pointsRef.current) return;
          const time = state.clock.getElapsedTime();
          pointsRef.current.position.y = position[1] + Math.sin(time * 0.5 + position[1]) * 0.05;
        });

        return (
          <points ref={pointsRef} position={position} key={text}>
            <bufferGeometry>
              <bufferAttribute
                attach="attributes-position"
                count={particles.length / 3}
                array={particles}
                itemSize={3}
              />
            </bufferGeometry>
            <pointsMaterial
              attach="material"
              color={color}
              size={0.05} 
              sizeAttenuation={true}
              transparent={true}
              opacity={0.95}
              blending={THREE.AdditiveBlending}
              depthWrite={false}
            />
          </points>
        );
      };

      const Scene = () => {
        const timeLeft = useCountdown('2026-01-01T00:00:00');
        
        const totalHours = timeLeft.days * 24 + timeLeft.hours;
        const pad = (n) => n.toString().padStart(2, '0');
        
        const countdownString = `${pad(totalHours)} : ${pad(timeLeft.minutes)} : ${pad(timeLeft.seconds)}`;

        // Color Palette
        const SILVER_BRIGHT = "#FFFFFF"; 
        const TITANIUM_GREY = "#6B7280"; 
        const SILVER_DARK = "#9CA3AF"; 

        return (
          <group>
            {/* Top Title - Literary Font ("ZCOOL XiaoWei") */}
            <ParticleText 
              text="距离 2026" 
              size={1.1} 
              position={[0, 2.2, 0]} 
              color={TITANIUM_GREY} 
              density={2} 
              fontFamily='"ZCOOL XiaoWei", serif'
            />

            {/* Main Countdown - Monospaced Digital Clock Style */}
            <ParticleText 
              text={countdownString} 
              size={3.0} 
              position={[0, 0, 0]} 
              color={SILVER_BRIGHT} 
              density={2.5} 
              fontFamily="'Share Tech Mono', monospace" 
            />

            {/* Signature Footer */}
            <ParticleText 
              text="MENGTIAN LIVESHOW" 
              size={1.2} 
              position={[0, -2.2, 0]} 
              color={SILVER_DARK} 
              density={1.5}
              fontFamily="'Orbitron', sans-serif" 
            />
          </group>
        );
      };

      const CameraRig = () => {
        useFrame((state) => {
          const t = state.clock.elapsedTime;
          // X axis sway: moves between -6 and 6
          state.camera.position.x = Math.sin(t * 0.15) * 6;
          // Slight Z axis breathing: moves between 18 and 22
          state.camera.position.z = 20 + Math.cos(t * 0.1) * 2;
          // Ensure camera always looks at the center text
          state.camera.lookAt(0, 0, 0);
        });
        return null;
      };

      const App = () => {
        return (
          <div className="w-screen h-screen bg-black relative overflow-hidden">
            <div className="absolute top-0 left-0 w-full h-full z-0">
              <Canvas camera={{ position: [0, 0, 20], fov: 45 }} dpr={[1, 2]}>
                <color attach="background" args={['#000000']} />
                <ambientLight intensity={0.2} /> 
                
                <Suspense fallback={null}>
                  <Scene />
                </Suspense>
                
                <CameraRig />

                <EffectComposer>
                  <Bloom 
                    luminanceThreshold={0.2} 
                    mipmapBlur 
                    intensity={0.25} 
                    radius={0.3}
                  />
                </EffectComposer>
              </Canvas>
            </div>
          </div>
        );
      };

      // --- INITIALIZATION ---
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>